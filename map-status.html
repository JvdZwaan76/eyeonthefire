// Fire Map Script - Fixed Implementation
document.addEventListener('DOMContentLoaded', function() {
    // Constants
    const DEFAULT_CENTER = [39.8283, -98.5795]; // Center of US
    const DEFAULT_ZOOM = 4;
    
    // DOM Elements
    const mapElement = document.getElementById('map');
    const statusElement = document.getElementById('status');
    const resetViewBtn = document.getElementById('reset-view-btn');
    const locateMeBtn = document.getElementById('locate-me-btn');
    const loadingOverlay = document.getElementById('loading-overlay');
    
    // Check if map element exists
    if (!mapElement) {
        console.error('Map element not found!');
        return;
    }
    
    // Initialize map with better options
    const map = L.map('map', {
        center: DEFAULT_CENTER,
        zoom: DEFAULT_ZOOM,
        minZoom: 3,
        maxZoom: 18,
        zoomControl: true,
        scrollWheelZoom: true
    });
    
    // Add base map layer with more detailed attribution
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | Fire data: <a href="https://firms.modaps.eosdis.nasa.gov/">NASA FIRMS</a>',
        maxZoom: 19
    }).addTo(map);
    
    // Initialize marker cluster group with improved options
    const markers = L.markerClusterGroup({
        disableClusteringAtZoom: 10,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        maxClusterRadius: 50
    });
    map.addLayer(markers);
    
    // Set status with improved error handling
    function setStatus(message, type = 'loading') {
        if (!statusElement) {
            console.error('Status element not found');
            return;
        }
        
        statusElement.className = 'status-bar ' + type;
        
        let icon = '<i class="fas fa-spinner fa-spin"></i>';
        if (type === 'success') {
            icon = '<i class="fas fa-check-circle"></i>';
        } else if (type === 'warning') {
            icon = '<i class="fas fa-exclamation-triangle"></i>';
        } else if (type === 'error') {
            icon = '<i class="fas fa-times-circle"></i>';
        }
        
        statusElement.innerHTML = icon + ' ' + message;
    }
    
    // Improved fire icon with better visibility
    function createFireIcon(confidence) {
        // Set color based on confidence
        let markerColor = 'red'; // Default
        let size = 10;
        
        if (confidence < 30) {
            markerColor = 'yellow';
            size = 8;
        } else if (confidence < 80) {
            markerColor = 'orange';
            size = 9;
        } else {
            size = 10;
        }
        
        return L.divIcon({
            html: `<div style="background-color: ${markerColor}; width: ${size}px; height: ${size}px; border-radius: 50%; border: 1.5px solid rgba(255,255,255,0.8); box-shadow: 0 0 3px rgba(0,0,0,0.3);"></div>`,
            className: '',
            iconSize: [size + 3, size + 3],
            iconAnchor: [(size + 3)/2, (size + 3)/2]
        });
    }
    
    // Improved popup for fire data
    function createFirePopup(fire) {
        let popupContent = '<div class="fire-popup" style="max-width: 250px; max-height: 250px; overflow-y: auto; padding: 5px;">';
        popupContent += '<h4 style="margin-top: 0; margin-bottom: 10px; color: #d32f2f; border-bottom: 1px solid #eee; padding-bottom: 5px;">Fire Detection</h4>';
        
        // Format acquisition date/time if available
        if (fire.acq_date && fire.acq_time) {
            try {
                const dateStr = fire.acq_date;
                const timeStr = String(fire.acq_time).padStart(4, '0');
                const hours = timeStr.slice(0, 2);
                const minutes = timeStr.slice(2, 4);
                
                // Convert to local time
                const fireDate = new Date(`${dateStr}T${hours}:${minutes}:00Z`);
                const localDateStr = fireDate.toLocaleDateString();
                const localTimeStr = fireDate.toLocaleTimeString();
                
                popupContent += `<strong>Detected:</strong> ${localDateStr} at ${localTimeStr}<br>`;
                popupContent += `<strong>UTC Time:</strong> ${dateStr} ${hours}:${minutes}<br>`;
            } catch (e) {
                // Fallback if date parsing fails
                popupContent += `<strong>Date:</strong> ${fire.acq_date}<br>`;
                popupContent += `<strong>Time:</strong> ${fire.acq_time}<br>`;
            }
        }
        
        // Add confidence with visual indicator
        if (fire.confidence) {
            const confidenceValue = parseInt(fire.confidence);
            let confidenceClass = 'low';
            
            if (confidenceValue >= 80) confidenceClass = 'high';
            else if (confidenceValue >= 30) confidenceClass = 'medium';
            
            popupContent += `<strong>Confidence:</strong> <span class="${confidenceClass}">${fire.confidence}%</span><br>`;
        }
        
        // Add brightness if available
        if (fire.brightness || fire.bright_t31) {
            const brightness = fire.brightness || fire.bright_t31;
            popupContent += `<strong>Brightness:</strong> ${parseFloat(brightness).toFixed(1)} K<br>`;
        }
        
        // Add FRP if available
        if (fire.frp) {
            popupContent += `<strong>Fire Radiative Power:</strong> ${parseFloat(fire.frp).toFixed(1)} MW<br>`;
        }
        
        // Add satellite info
        if (fire.satellite) {
            popupContent += `<strong>Satellite:</strong> ${fire.satellite}<br>`;
        }
        
        // Add coordinates with copy button
        const lat = parseFloat(fire.latitude || fire.lat || 0).toFixed(6);
        const lng = parseFloat(fire.longitude || fire.lon || 0).toFixed(6);
        
        popupContent += `<div class="coordinates">`;
        popupContent += `<strong>Coordinates:</strong><br>`;
        popupContent += `<span>${lat}, ${lng}</span>`;
        popupContent += `</div>`;
        
        // Add links to other services
        popupContent += `<div class="external-links" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;">`;
        popupContent += `<small><a href="https://www.google.com/maps?q=${lat},${lng}" target="_blank" rel="noopener noreferrer">View in Google Maps</a></small>`;
        popupContent += `</div>`;
        
        popupContent += '</div>';
        return popupContent;
    }
    
    // Display fire data on map with improved error handling
    function displayFires(fires) {
        // Clear existing markers
        markers.clearLayers();
        
        if (!fires || !Array.isArray(fires) || fires.length === 0) {
            setStatus('No fire data available', 'warning');
            return;
        }
        
        // Track valid points for bounds
        const validPoints = [];
        let count = 0;
        
        // Add markers for each fire
        fires.forEach(fire => {
            try {
                // Extract coordinates - handle different possible property names
                const lat = parseFloat(fire.latitude || fire.lat || '');
                const lng = parseFloat(fire.longitude || fire.lon || '');
                
                // Skip invalid coordinates
                if (isNaN(lat) || isNaN(lng) || lat === 0 || lng === 0) {
                    return;
                }
                
                // Validate coordinates are within reasonable bounds
                if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    return;
                }
                
                // Get confidence level with fallback
                const confidence = parseFloat(fire.confidence || 0);
                
                // Create marker with appropriate icon
                const marker = L.marker([lat, lng], {
                    icon: createFireIcon(confidence)
                });
                
                // Build popup content
                const popupContent = createFirePopup(fire);
                marker.bindPopup(popupContent);
                
                // Store the fire data in the marker for potential later use
                marker.fireData = fire;
                
                // Add to cluster layer
                markers.addLayer(marker);
                validPoints.push([lat, lng]);
                count++;
            } catch (e) {
                console.warn('Error processing fire data point:', e);
            }
        });
        
        // Fit map to bounds if we have points
        if (validPoints.length > 0) {
            try {
                const bounds = L.latLngBounds(validPoints);
                if (bounds.isValid()) {
                    map.fitBounds(bounds, {
                        padding: [50, 50],
                        maxZoom: 10
                    });
                }
                setStatus(`Showing ${count} fire detections`, 'success');
            } catch (e) {
                console.error('Error setting map bounds:', e);
                // Fallback to default view
                map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);
                setStatus(`Showing ${count} fire detections (error fitting bounds)`, 'warning');
            }
        } else {
            setStatus('No fire detections found in this region', 'warning');
        }
    }
    
    // Generate more realistic fire data across the western US
    // This is a fallback for demo purposes
    function getSampleFireData() {
        // Create a realistic sample based on actual FIRMS data format
        const sampleData = [];
        const satellites = ['MODIS', 'VIIRS', 'VIIRS_SNPP'];
        
        // Western US fire-prone areas
        const basePoints = [
            {lat: 34.05, lng: -118.24, name: "Los Angeles Area"}, // LA
            {lat: 37.77, lng: -122.41, name: "San Francisco Area"}, // SF
            {lat: 38.58, lng: -121.49, name: "Sacramento Area"}, // Sacramento
            {lat: 36.77, lng: -119.77, name: "Fresno Area"}, // Fresno
            {lat: 32.71, lng: -117.16, name: "San Diego Area"}, // San Diego
            {lat: 35.37, lng: -119.01, name: "Bakersfield Area"}, // Bakersfield
            {lat: 33.83, lng: -116.53, name: "Palm Springs Area"}, // Palm Springs
            {lat: 39.52, lng: -121.55, name: "Chico Area"}, // Chico
            {lat: 40.58, lng: -124.15, name: "Eureka Area"}, // Eureka
            {lat: 41.71, lng: -122.64, name: "Mount Shasta Area"}, // Mt Shasta
            {lat: 46.87, lng: -113.99, name: "Montana Mountains"}, // Montana
            {lat: 43.61, lng: -116.21, name: "Boise Area"}, // Boise, Idaho
            {lat: 35.68, lng: -105.94, name: "Santa Fe Area"}, // Santa Fe, NM
            {lat: 38.47, lng: -106.04, name: "Colorado Mountains"}, // Colorado
            {lat: 44.06, lng: -121.32, name: "Bend, Oregon"}, // Bend, OR
            {lat: 47.60, lng: -122.33, name: "Seattle Area"} // Seattle, WA
        ];
        
        // Get current date
        const currentDate = new Date();
        
        // Generate fire points for each base location
        basePoints.forEach(base => {
            // Randomly determine how many fires in this area (0-5)
            const fireCount = Math.floor(Math.random() * 6);
            const satellite = satellites[Math.floor(Math.random() * satellites.length)];
            
            for (let i = 0; i < fireCount; i++) {
                // Create some variation in location
                const latOffset = (Math.random() - 0.5) * 0.5;
                const lngOffset = (Math.random() - 0.5) * 0.5;
                
                // Generate random time in the past 48 hours
                const hoursAgo = Math.floor(Math.random() * 48);
                const fireDate = new Date(currentDate);
                fireDate.setHours(fireDate.getHours() - hoursAgo);
                
                // Format date as YYYY-MM-DD
                const acq_date = fireDate.toISOString().split('T')[0];
                
                // Format time as HHMM
                const hours = fireDate.getHours().toString().padStart(2, '0');
                const minutes = fireDate.getMinutes().toString().padStart(2, '0');
                const acq_time = hours + minutes;
                
                // Generate random confidence level
                const confidence = Math.floor(Math.random() * 100) + 1;
                
                // Generate random brightness temperature
                const brightness = 300 + Math.floor(Math.random() * 100);
                
                // Add to sample data
                sampleData.push({
                    latitude: base.lat + latOffset,
                    longitude: base.lng + lngOffset,
                    brightness: brightness,
                    scan: 0.5 + Math.random(),
                    track: 0.5 + Math.random(),
                    acq_date: acq_date,
                    acq_time: acq_time,
                    satellite: satellite,
                    confidence: confidence,
                    version: '1.0',
                    bright_t31: brightness - 10,
                    frp: Math.random() * 50
                });
            }
        });
        
        return sampleData;
    }
    
    // Improved CSV parser with better error handling
    function parseCSVData(csvText) {
        try {
            // Check if data is present
            if (!csvText || typeof csvText !== 'string' || csvText.trim() === '') {
                console.warn('Empty CSV data');
                return [];
            }
            
            // Split the CSV text into lines
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                console.warn('Not enough lines in CSV data');
                return [];
            }
            
            // Get headers from the first line
            const headers = lines[0].split(',').map(h => h.trim());
            if (headers.length < 2) {
                console.warn('Not enough columns in CSV header');
                return [];
            }
            
            // Parse each data line
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Handle quoted values properly
                const values = [];
                let inQuotes = false;
                let currentValue = '';
                
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    
                    if (char === '"' && (j === 0 || line[j-1] !== '\\')) {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentValue);
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                
                values.push(currentValue); // Add the last field
                
                // Skip if number of values doesn't match headers
                if (values.length !== headers.length) {
                    console.warn(`Skipping line ${i+1}: column count mismatch`);
                    continue;
                }
                
                // Create object with headers as keys
                const item = {};
                headers.forEach((header, i) => {
                    item[header] = values[i] ? values[i].replace(/"/g, '') : '';
                });
                
                data.push(item);
            }
            
            return data;
        } catch (e) {
            console.error('Error parsing CSV data:', e);
            return [];
        }
    }
    
    // Improved data format detection and parsing
    function parseData(responseText) {
        try {
            // Check if data is present
            if (!responseText || typeof responseText !== 'string' || responseText.trim() === '') {
                console.warn('Empty response data');
                return [];
            }
            
            // If it starts with { or [, try to parse as JSON
            if ((responseText.trim().startsWith('{') || responseText.trim().startsWith('['))) {
                try {
                    const jsonData = JSON.parse(responseText);
                    
                    // Handle different JSON formats
                    if (Array.isArray(jsonData)) {
                        return jsonData;
                    } else if (jsonData.features && Array.isArray(jsonData.features)) {
                        // GeoJSON format
                        return jsonData.features.map(feature => {
                            const props = feature.properties || {};
                            const coords = feature.geometry?.coordinates || [];
                            
                            return {
                                ...props,
                                longitude: coords[0],
                                latitude: coords[1]
                            };
                        });
                    } else if (jsonData.data && Array.isArray(jsonData.data)) {
                        // API response format with data property
                        return jsonData.data;
                    } else {
                        // Single object
                        return [jsonData];
                    }
                } catch (e) {
                    console.warn('Failed to parse as JSON, trying CSV');
                }
            }
            
            // Try to parse as CSV
            return parseCSVData(responseText);
        } catch (e) {
            console.error('Failed to parse response:', e);
            return [];
        }
    }
    
    // Load fire data with proper API integration
    async function loadFireData() {
        try {
            // Show loading status
            setStatus('Loading fire data...');
            if (loadingOverlay) loadingOverlay.classList.remove('hidden');
            
            let fireData = [];
            
            // First try to fetch from the API
            try {
                const response = await fetch('/api/fires/');
                
                if (!response.ok) {
                    throw new Error(`API returned status ${response.status}`);
                }
                
                const responseText = await response.text();
                const parsedData = parseData(responseText);
                
                if (parsedData && parsedData.length > 0) {
                    fireData = parsedData;
                    console.log(`Loaded ${fireData.length} fire data points from API`);
                } else {
                    throw new Error('No data returned from API');
                }
            } catch (apiError) {
                console.warn('API error, using sample data:', apiError);
                // Fall back to sample data
                fireData = getSampleFireData();
                console.log(`Using ${fireData.length} sample fire data points`);
            }
            
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
            
            if (fireData.length > 0) {
                displayFires(fireData);
            } else {
                setStatus('No fire data available', 'warning');
            }
            
        } catch (error) {
            console.error('Error loading fire data:', error);
            setStatus('Error loading fire data', 'error');
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
            
            // Use fallback data in case of error
            const fallbackData = getSampleFireData();
            if (fallbackData.length > 0) {
                displayFires(fallbackData);
            }
        }
    }
    
    // Reset view to default
    function resetView() {
        map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);
        setStatus('View reset to United States', 'success');
    }
    
    // Locate user with improved error handling
    function locateUser() {
        setStatus('Getting your location...');
        if (loadingOverlay) loadingOverlay.classList.remove('hidden');
        
        if (!navigator.geolocation) {
            setStatus('Geolocation is not supported by this browser', 'error');
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
            alert('Geolocation is not supported by this browser');
            return;
        }
        
        // Set timeout for geolocation request
        const geoLocationTimeout = setTimeout(() => {
            setStatus('Location request timed out', 'error');
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
        }, 15000); // 15 seconds timeout
        
        navigator.geolocation.getCurrentPosition(
            // Success
            function(position) {
                clearTimeout(geoLocationTimeout);
                
                try {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    
                    if (isNaN(lat) || isNaN(lng)) {
                        throw new Error('Invalid coordinates returned');
                    }
                    
                    // Fly to user location with animation
                    map.flyTo([lat, lng], 10, {
                        animate: true,
                        duration: 1.5
                    });
                    
                    // Add a temporary marker for user location
                    const userMarker = L.marker([lat, lng], {
                        icon: L.divIcon({
                            html: '<div style="background-color: blue; border: 2px solid white; border-radius: 50%; width: 12px; height: 12px; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>',
                            className: '',
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                        })
                    }).addTo(map);
                    
                    userMarker.bindPopup('Your location').openPopup();
                    
                    // Remove marker after 10 seconds
                    setTimeout(() => {
                        map.removeLayer(userMarker);
                    }, 10000);
                    
                    setStatus('Showing fires near your location', 'success');
                } catch (e) {
                    console.error('Error processing location:', e);
                    setStatus('Error processing your location', 'error');
                }
                
                if (loadingOverlay) loadingOverlay.classList.add('hidden');
            },
            // Error
            function(error) {
                clearTimeout(geoLocationTimeout);
                console.error('Geolocation error:', error);
                
                let errorMessage = 'Location access denied';
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        errorMessage = 'Location access denied';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMessage = 'Location information unavailable';
                        break;
                    case error.TIMEOUT:
                        errorMessage = 'Location request timed out';
                        break;
                    case error.UNKNOWN_ERROR:
                        errorMessage = 'An unknown error occurred';
                        break;
                }
                
                setStatus(`Could not get your location: ${errorMessage}`, 'error');
                if (loadingOverlay) loadingOverlay.classList.add('hidden');
                
                // More user-friendly alert
                const alertMsg = `Unable to access your location: ${errorMessage}. 
                If you want to see fires near you, please enable location access in your browser settings.`;
                
                alert(alertMsg);
            },
            // Options
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
    }
    
    // Add map zoom controls in better position
    L.control.zoom({
        position: 'topright'
    }).addTo(map);
    
    // Set up event listeners with error handling
    if (resetViewBtn) {
        resetViewBtn.addEventListener('click', resetView);
    }
    
    if (locateMeBtn) {
        locateMeBtn.addEventListener('click', locateUser);
    }
    
    // Add responsive behavior to map
    function handleResize() {
        // Adjust map size and bounds based on screen size
        if (window.innerWidth <= 768) {
            // Mobile
            if (mapElement.style.height !== '50vh') {
                mapElement.style.height = '50vh';
                map.invalidateSize();
            }
        } else {
            // Desktop
            if (mapElement.style.height !== '70vh') {
                mapElement.style.height = '70vh';
                map.invalidateSize();
            }
        }
    }
    
    // Initial resize and add listener
    handleResize();
    window.addEventListener('resize', handleResize);
    
    // Initial load
    loadFireData();
    
    // Export map instance for potential external use
    window.fireMap = map;
});
